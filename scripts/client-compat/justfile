# Client compatibility tests for duckgres
default:
    just --list

# Run all client tests with results report
all: build
    #!/usr/bin/env bash
    docker compose up -d
    docker compose wait results-gatherer
    exit_code=$?
    docker compose logs results-gatherer | tail -80
    docker compose down -v
    exit "${exit_code}"

# Build all containers
build:
    docker compose build

# Run psycopg2 compatibility tests (standalone, no report)
[group('client')]
psycopg: build
    docker compose run --rm psycopg
    docker compose down -v

# Run harlequin compatibility tests (standalone, no report)
[group('client')]
harlequin: build
    docker compose run --rm harlequin
    docker compose down -v

# Run pgx (Go) compatibility tests (standalone, no report)
[group('client')]
pgx: build
    docker compose run --rm pgx
    docker compose down -v

# Run psql compatibility tests (standalone, no report)
[group('client')]
psql: build
    docker compose run --rm psql
    docker compose down -v

# Run JDBC compatibility tests (standalone, no report)
[group('client')]
jdbc: build
    docker compose run --rm jdbc
    docker compose down -v

# Run Rust (tokio-postgres) compatibility tests (standalone, no report)
[group('client')]
rust: build
    docker compose run --rm rust
    docker compose down -v

# Run SQLAlchemy compatibility tests (standalone, no report)
[group('client')]
sqlalchemy: build
    docker compose run --rm sqlalchemy
    docker compose down -v

# Tear down containers and volumes
down:
    docker compose down -v

# Remove results directory
clean:
    rm -rf results

# Open the most recent results database in the DuckDB CLI
query-last-run:
    #!/usr/bin/env bash
    if [ ! -d results ]; then
        echo "No results directory found. Run 'just all' first."
        exit 1
    fi
    db=$(ls -t results/*.duckdb 2>/dev/null | head -1)
    if [ -z "$db" ]; then
        echo "No .duckdb files found in results/. Run 'just all' first."
        exit 1
    fi
    echo "Opening $db"
    duckdb "$db"
