package server

import (
	"bufio"
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

// Exit codes for child processes
const (
	ExitSuccess     = 0  // Clean disconnect
	ExitError       = 1  // Error (crash, protocol error)
	ExitAuthFailure = 10 // Authentication failure (triggers rate limit update)
)

// ChildConfig contains all configuration needed by a child worker process.
// It is passed from parent to child via the DUCKGRES_CHILD_CONFIG env var as JSON.
type ChildConfig struct {
	// Connection info (RemoteAddr is known at spawn time; Username/Database are read after TLS)
	RemoteAddr string `json:"remote_addr"`

	// Server config
	DataDir     string   `json:"data_dir"`
	Extensions  []string `json:"extensions"`
	IdleTimeout int64    `json:"idle_timeout"` // nanoseconds

	// TLS config
	TLSCertFile string `json:"tls_cert_file"`
	TLSKeyFile  string `json:"tls_key_file"`

	// DuckLake config
	DuckLake DuckLakeConfig `json:"ducklake"`

	// Authentication - map of username -> password
	// Child will look up after reading username from startup message
	Users map[string]string `json:"users"`

	// Backend key (pre-generated by parent for cancel request routing)
	// BackendPid is set to child's actual PID after fork
	BackendSecretKey int32 `json:"backend_secret_key"`

	// ServerStartTime is the parent server's start time (Unix nanoseconds).
	// Used to distinguish server uptime from child process uptime.
	ServerStartTime int64 `json:"server_start_time"`
}

// RunChildMode is the entry point for child worker processes.
// It reconstructs the TCP connection from FD 3, completes TLS handshake,
// authenticates the user, creates a DuckDB connection, and runs the message loop.
//
// Configuration is read from stdin as JSON (more secure than env vars for passwords).
//
// Exit codes:
//   - 0: Success (clean disconnect)
//   - 1: Error (crash, protocol error)
//   - 10: Authentication failure
func RunChildMode() {
	// Read configuration from stdin (passed by parent via pipe)
	// This is more secure than env vars because stdin is a private pipe
	// that cannot be read by other processes via /proc/<pid>/environ
	configJSON, err := io.ReadAll(os.Stdin)
	if err != nil {
		slog.Error("Failed to read config from stdin", "error", err)
		os.Exit(ExitError)
	}

	if len(configJSON) == 0 {
		slog.Error("No config received on stdin")
		os.Exit(ExitError)
	}

	var cfg ChildConfig
	if err := json.Unmarshal(configJSON, &cfg); err != nil {
		slog.Error("Failed to parse child config", "error", err)
		os.Exit(ExitError)
	}

	slog.Info("Child worker starting",
		"remote_addr", cfg.RemoteAddr,
		"pid", os.Getpid())

	// Reconstruct TCP connection from FD 3 (passed by parent via ExtraFiles)
	// FD 0,1,2 are stdin/stdout/stderr, FD 3 is the first extra file
	file := os.NewFile(3, "tcp-conn")
	if file == nil {
		slog.Error("Failed to get TCP connection file descriptor")
		os.Exit(ExitError)
	}

	fileConn, err := net.FileConn(file)
	if err != nil {
		slog.Error("Failed to create net.Conn from file", "error", err)
		os.Exit(ExitError)
	}
	_ = file.Close() // Close the file handle, we have the conn now

	tcpConn, ok := fileConn.(*net.TCPConn)
	if !ok {
		slog.Error("Connection is not TCP")
		_ = fileConn.Close()
		os.Exit(ExitError)
	}

	// Run the worker with the connection
	exitCode := runChildWorker(tcpConn, &cfg)
	os.Exit(exitCode)
}

// runChildWorker handles a single client connection in a child process.
// Returns the appropriate exit code.
func runChildWorker(tcpConn *net.TCPConn, cfg *ChildConfig) int {
	// Set up signal handling for graceful shutdown and query cancellation
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT, syscall.SIGUSR1)

	// Create a context for shutdown signals (SIGTERM/SIGINT)
	shutdownCtx, shutdownCancel := context.WithCancel(context.Background())
	defer shutdownCancel()

	// Create a channel to signal query cancellation (SIGUSR1)
	// This is separate from shutdown so we can cancel queries without closing the connection
	queryCancelCh := make(chan struct{})
	var queryCancelOnce sync.Once

	// Handle signals in a goroutine
	go func() {
		for sig := range sigChan {
			switch sig {
			case syscall.SIGTERM, syscall.SIGINT:
				slog.Info("Received shutdown signal", "signal", sig)
				shutdownCancel()
			case syscall.SIGUSR1:
				slog.Info("Received query cancel signal")
				// Signal query cancellation (can be called multiple times safely)
				queryCancelOnce.Do(func() {
					close(queryCancelCh)
				})
			}
		}
	}()

	// Load TLS certificate
	cert, err := tls.LoadX509KeyPair(cfg.TLSCertFile, cfg.TLSKeyFile)
	if err != nil {
		slog.Error("Failed to load TLS certificates", "error", err)
		return ExitError
	}

	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},
	}

	// Complete TLS handshake with timeout to prevent slow clients from holding resources
	// Parent has already sent 'S' response to SSL request, we just need to do the handshake
	tlsConn := tls.Server(tcpConn, tlsConfig)

	// Set deadline for TLS handshake (30 seconds should be plenty)
	if err := tlsConn.SetDeadline(time.Now().Add(30 * time.Second)); err != nil {
		slog.Error("Failed to set TLS handshake deadline", "error", err)
		return ExitError
	}

	if err := tlsConn.Handshake(); err != nil {
		slog.Error("TLS handshake failed", "error", err, "remote_addr", cfg.RemoteAddr)
		return ExitError
	}

	// Clear deadline after successful handshake
	if err := tlsConn.SetDeadline(time.Time{}); err != nil {
		slog.Error("Failed to clear TLS deadline", "error", err)
		return ExitError
	}

	slog.Info("TLS connection established", "remote_addr", cfg.RemoteAddr)

	// Create client connection handler
	reader := bufio.NewReader(tlsConn)
	writer := bufio.NewWriter(tlsConn)

	// Read startup message (sent by client after TLS handshake)
	params, err := readStartupMessage(reader)
	if err != nil {
		slog.Error("Failed to read startup message", "error", err)
		return ExitError
	}

	username := params["user"]
	database := params["database"]

	if username == "" {
		slog.Error("No user specified in startup message")
		_ = writeErrorResponse(writer, "FATAL", "28000", "no user specified")
		_ = writer.Flush()
		return ExitError
	}

	// Look up expected password for this user
	expectedPassword, ok := cfg.Users[username]
	if !ok {
		slog.Warn("Unknown user", "user", username, "remote_addr", cfg.RemoteAddr)
		authFailuresCounter.Inc()
		_ = writeErrorResponse(writer, "FATAL", "28P01", "password authentication failed")
		_ = writer.Flush()
		return ExitAuthFailure
	}

	// Request password
	if err := writeAuthCleartextPassword(writer); err != nil {
		slog.Error("Failed to request password", "error", err)
		return ExitError
	}
	if err := writer.Flush(); err != nil {
		slog.Error("Failed to flush writer", "error", err)
		return ExitError
	}

	// Read password response
	msgType, body, err := readMessage(reader)
	if err != nil {
		slog.Error("Failed to read password message", "error", err)
		return ExitError
	}

	if msgType != msgPassword {
		slog.Error("Expected password message", "got", string(msgType))
		_ = writeErrorResponse(writer, "FATAL", "28000", "expected password message")
		_ = writer.Flush()
		return ExitError
	}

	// Password is null-terminated
	password := string(bytes.TrimRight(body, "\x00"))
	if password != expectedPassword {
		slog.Warn("Authentication failed", "user", username, "remote_addr", cfg.RemoteAddr)
		authFailuresCounter.Inc()
		_ = writeErrorResponse(writer, "FATAL", "28P01", "password authentication failed")
		_ = writer.Flush()
		return ExitAuthFailure
	}

	// Send auth OK
	if err := writeAuthOK(writer); err != nil {
		slog.Error("Failed to send auth OK", "error", err)
		return ExitError
	}

	slog.Info("User authenticated", "user", username, "remote_addr", cfg.RemoteAddr)

	// Create a minimal server config for the worker
	serverCfg := Config{
		DataDir:     cfg.DataDir,
		Extensions:  cfg.Extensions,
		DuckLake:    cfg.DuckLake,
		IdleTimeout: time.Duration(cfg.IdleTimeout),
		TLSCertFile: cfg.TLSCertFile,
		TLSKeyFile:  cfg.TLSKeyFile,
		Users:       cfg.Users,
	}

	// Reconstruct parent server start time for uptime() macro.
	// Fall back to this process's start time if the field is missing (e.g.,
	// rolling upgrade where old parent doesn't set ServerStartTime).
	parentStartTime := processStartTime
	if cfg.ServerStartTime != 0 {
		parentStartTime = time.Unix(0, cfg.ServerStartTime)
	}

	// Create DuckDB connection
	db, err := CreateDBConnection(serverCfg, make(chan struct{}, 1), username, parentStartTime)
	if err != nil {
		slog.Error("Failed to create database connection", "error", err)
		_ = writeErrorResponse(writer, "FATAL", "28000", fmt.Sprintf("failed to open database: %v", err))
		_ = writer.Flush()
		return ExitError
	}

	// Get our PID for backend key
	pid := int32(os.Getpid())

	// Create client connection struct
	clientConn := &clientConn{
		server:    nil, // Will set up a minimal interface
		conn:      tlsConn,
		reader:    reader,
		writer:    writer,
		username:  username,
		database:  database,
		executor:  NewLocalExecutor(db),
		pid:       pid,
		secretKey: cfg.BackendSecretKey,
		stmts:     make(map[string]*preparedStmt),
		portals:   make(map[string]*portal),
		txStatus:  txStatusIdle,
	}

	// Set up worker server reference for clientConn
	clientConn.server = &Server{
		cfg: serverCfg,
		// Minimal server for child process - no listener, rate limiter, etc.
		activeQueries:    make(map[BackendKey]context.CancelFunc),
		duckLakeSem:      make(chan struct{}, 1),
		externalCancelCh: queryCancelCh, // Wire signal-based cancellation to query context
	}

	// Ensure cleanup on exit
	defer func() {
		if clientConn.executor != nil {
			clientConn.safeCleanupDB()
		}
	}()

	// Send initial parameters
	clientConn.sendInitialParams()

	// Send ready for query
	if err := writeReadyForQuery(writer, clientConn.txStatus); err != nil {
		slog.Error("Failed to send ready for query", "error", err)
		return ExitError
	}
	if err := writer.Flush(); err != nil {
		slog.Error("Failed to flush writer", "error", err)
		return ExitError
	}

	// Run message loop with context for cancellation
	errChan := make(chan error, 1)
	go func() {
		errChan <- clientConn.messageLoop()
	}()

	select {
	case err := <-errChan:
		if err != nil {
			slog.Error("Message loop error", "error", err)
			return ExitError
		}
		slog.Info("Client disconnected cleanly", "user", username, "remote_addr", cfg.RemoteAddr)
		return ExitSuccess

	case <-shutdownCtx.Done():
		slog.Info("Worker shutting down due to signal", "user", username)
		_ = tlsConn.Close()
		return ExitSuccess
	}
}

